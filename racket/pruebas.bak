#lang racket

(define (is-valid row col value)
  ;; Comprobar si el valor ya está en la fila o en la columna
  (define row-values (vector-ref board row))
  (define col-values (for/vector ([i N]) (vector-ref board i col)))
  (define value-in-row (ormap (lambda (x) (= x value)) row-values))
  (define value-in-col (ormap (lambda (x) (= x value)) col-values))
  
  ;; Comprobar si el valor cumple con las pistas
  (define (count-visible-buildings lst)
    (define (count-visible-buildings-helper lst max-height count)
      (cond
        [(null? lst) count]
        [(> (car lst) max-height)
         (count-visible-buildings-helper (cdr lst) (car lst) (add1 count))]
        [else
         (count-visible-buildings-helper (cdr lst) max-height count)]))
    (count-visible-buildings-helper lst 0 1))
  
  (cond
    [(or value-in-row value-in-col) #f]
    [(= col (- N 1)) ;; Última columna, comprobar la pista de la derecha
     (define (get-row i) (vector-ref board row i))
     (define seen (count-visible-buildings (reverse (for/list ([i (range (- N 2) -1 -1)]) (get-row i)))))
     (not (= seen (vector-ref right row)))]
    [(= row (- N 1)) ;; Última fila, comprobar la pista de abajo
     (define (get-col i) (vector-ref board i col))
     (define seen (count-visible-buildings (reverse (for/list ([i (range (- N 2) -1 -1)]) (get-col i)))))
     (not (= seen (vector-ref bottom col)))]
    [else #t]))

(define (solve row col)
  ;; Si se ha llegado al final del tablero, el puzzle está resuelto
  (cond
    [(and (= row N) (= col 0)) #t]
    [(= col N) (solve (add1 row) 0)]
    [else
     ;; Probar todos los valores posibles de 1 a N
     (define (try-value value)
       (cond
         [(is-valid row col value)
          ;; Colocar el valor en el tablero
          (vector-set! (vector-ref board row) col value)
          ;; Intentar resolver el resto del tablero
          (when (solve row (add1 col))
              #t
              ;; Si no se puede resolver, deshacer el cambio y probar otro valor
              (vector-set! (vector-ref board row) col 0)
              #f)])
       (when (<= value N)
           (or (try-value (add1 value))
               (try-value (add1 value)))))
     (try-value 1)]))

;; Pedir al usuario que introduzca el tamaño del tablero
(define N (string->number (read-line "Introduce el tamaño del tablero: ")))

;; Pedir al usuario que introduzca los valores de las pistas
(define top (for/list ([_ (in-range N)]) (string->number (read-line "Introduce las pistas desde NORTE, separadas por espacios: "))))
(define bottom (for/list ([_ (in-range N)]) (string->number (read-line "Introduce las pistas desde SUR, separadas por espacios: "))))
(define left (for/list ([_ (in-range N)]) (string->number (read-line "Introduce las pistas desde la OESTE, separadas por espacios: "))))
(define right (for/list ([_ (in-range N)]) (string->number (read-line "Introduce las pistas desde la ESTE, separadas por espacios: "))))

;; Crear una matriz vacía para almacenar las alturas de los edificios
(define board (make-vector N (make-vector N 0)))

;; Llamar a la función de resolver e imprimir el resultado
(when (solve 0 0)
    (begin
      (displayln "Solución:")
      (for ([row (in-vector board)])
        (displayln row)))
    (displayln "No hay solución"))